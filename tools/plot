#!/usr/bin/env python3

import argparse
import sys

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import numpy as np
import pandas as pd
from scipy.signal import savgol_filter

# "CN color spec", see https://matplotlib.org/stable/tutorials/colors/colors.html#specifying-colors
COLORS = [f"C{i}" for i in range(11)]


COLUMNS = (
    "ack_seq",
    "base_rtt",
    "beta",
    "cwnd",
    "ev",
    "p_norm",
    "qlen",
    "rate",
    "time",
)

FORMATS = {
    "ack_seq": ".",
}

LABELS = {
    "ack_seq": "ACK'ed sequence #",
    "base_rtt": "Base RTT",
    "beta": "Additive increase β",
    "cwnd": "Congestion window",
    "ev": "Resets",
    "p_norm": "Normalized power",
    "qlen": "Queue length",
    "rate": "Transmission rate",
    "time": "Time",
}

LIMITS = {
    "rate": (0, 100 * 10 ** 9),
}

PRETTY_UNITS = {
    "bit^2/s": r"$\frac{bit^2}{s}$",
    "us": "µs",
}

UNIT_FACTORS = {
    "bit/s": 8,
    "ms": 0.001,
    "s": 0.000001,
}

# The first unit specified for a column, if any, is the default unit:
UNITS = {
    "base_rtt": ("us", "ms", "s"),
    "beta": ("bytes",),
    "cwnd": ("bytes",),
    "ev": (None,),
    "p_norm": ("bit^2/s",),
    "qlen": ("bytes"),
    "rate": ("bytes/s", "bit/s"),
    "time": ("us", "ms", "s"),
}


class DictStrArg:
    def __init__(self, value_type):
        self._value_type = value_type

    def __call__(self, list_str):
        d = {}
        for s in list_str.split(","):
            k, v = s.split(":")
            if v is not None:
                v = self._value_type(v)
            d[k] = v
        return d

    def __repr__(self):
        return self._value_type.__name__


def check_unit(col, unit):
    units = UNITS.get(col, (None,))
    if unit is None:
        unit = units[0]
    if unit not in (None, *units):
        raise LookupError(f"unit “{unit}“ not available for “{col}“")
    return unit


def set_ylim(axis, min_val, max_val, min_lim, max_lim):
    try:
        min_val = max(min_val, min_lim)
    except TypeError:
        pass
    try:
        max_val = min(max_val, max_lim)
    except TypeError:
        pass
    _, ymargin = axis.margins()
    the_margin = ymargin * (max_val - min_val)
    axis.set_ylim(min_val - the_margin, max_val + the_margin)


def setup_axis(axis, col, unit):
    pretty_unit = PRETTY_UNITS.get(unit, unit)
    axis.set_minor_locator(ticker.AutoMinorLocator())

    if col in ("ack_seq", "cwnd"):
        axis.set_major_formatter(ticker.StrMethodFormatter("{x:.0f}"))
    else:
        if unit in ("bit/s", "bytes/s"):
            axis.set_major_formatter(ticker.EngFormatter(unit=pretty_unit))
        if unit in ("bit^2/s",):
            axis.set_major_formatter(ticker.EngFormatter(unit=pretty_unit, usetex=True))
        elif unit in ("s", "ms", "us"):
            precision = 0
            if unit == "s":
                precision = 3
            axis.set_major_formatter(
                ticker.StrMethodFormatter(f"{{x:.{precision}f}} {pretty_unit}")
            )


def main():
    early_argparser = argparse.ArgumentParser(add_help=False, allow_abbrev=False)
    early_argparser.add_argument(
        "--info",
        action="store_true",
        help="show information about the CSV file and exit",
    )
    early_args, remaining_argv = early_argparser.parse_known_args()

    argparser = argparse.ArgumentParser(
        add_help=True, allow_abbrev=False, parents=[early_argparser]
    )
    argparser.add_argument("csv_file", type=argparse.FileType("r"))

    if not early_args.info:
        argparser.add_argument(
            "--all-flows",
            action="store_true",
            help="plot a single data column for all flows",
        )
        argparser.add_argument("--fmt", default={}, type=DictStrArg(str))
        argparser.add_argument(
            "--flow",
            default=0,
            type=int,
            help="select a flow from the data by zero-based index",
        )
        argparser.add_argument("--max", default={}, type=DictStrArg(float))
        argparser.add_argument("--min", default={}, type=DictStrArg(float))
        argparser.add_argument(
            "--smooth",
            const=99,
            default=0,
            nargs="?",
            type=int,
            help="smooth the plotted data; an optionally given uneven integer number (greater than 2) specifies the filter window size",
        )
        argparser.add_argument("--title")
        argparser.add_argument("--unit", default={}, type=DictStrArg(str))
        argparser.add_argument("x", choices=COLUMNS)
        argparser.add_argument("y", choices=COLUMNS, nargs="+")

    args = argparser.parse_args(remaining_argv, early_args)

    df = pd.read_csv(args.csv_file)

    df["time"] -= df["time"].min()
    try:
        df["p_norm"] = df["p_norm_scaled"] / df["power_scale"]
    except KeyError:
        pass
    else:
        df = df.drop(columns=["p_norm_scaled", "power_scale"])

    if args.info:
        pd.options.display.float_format = "{:06.4f}".format
        df.info()
        print(f"\n{df.describe(percentiles=[])}")
        return

    if args.all_flows and len(args.y) > 1:
        print("can only plot one data column when plotting multiple flows")
        return

    available_hashes = df["hash"].sort_values().unique()
    if not args.all_flows:
        selected_hash = available_hashes[args.flow]
        df = df[df["hash"] == selected_hash]

    xunit = args.unit.get(args.x)
    try:
        xunit = check_unit(args.x, xunit)
    except LookupError as e:
        return e

    df[args.x] *= UNIT_FACTORS.get(xunit, 1)
    xmin = args.min.get(args.x, df[args.x].min())
    xmax = args.max.get(args.x, df[args.x].max())
    df = df[(df[args.x] >= xmin) & (df[args.x] <= xmax)]

    _fig, ax = plt.subplots(constrained_layout=True)
    ax.set_xlabel(LABELS.get(args.x, args.x))
    setup_axis(ax.xaxis, args.x, xunit)
    axx = None
    lines = []

    if args.all_flows:
        y = args.y[0]

        yfmt = args.fmt.get(y) or FORMATS.get(y, "-")
        ymax = args.max.get(y)
        ymin = args.min.get(y)
        yunit = args.unit.get(y)
        try:
            yunit = check_unit(y, yunit)
        except LookupError as e:
            return e
        df[y] *= UNIT_FACTORS.get(yunit, 1)

        grouped_df = df.groupby("hash")

        for i, flow_hash in enumerate(available_hashes):
            flow_df = grouped_df.get_group(flow_hash)
            y_vals = (
                savgol_filter(flow_df[y], args.smooth, 2)
                if args.smooth > 0
                else flow_df[y]
            )

            lines.extend(
                ax.plot(
                    flow_df[args.x],
                    y_vals,
                    yfmt,
                    label=f"Flow {i}",
                )
            )
    else:
        for i, y in enumerate(args.y):
            if args.x == y:
                return f"cannot use the same column “{args.x}” for x and y axis"

            ycolor = COLORS[i % len(COLORS)]
            yfmt = args.fmt.get(y) or FORMATS.get(y, "-")
            ymax = args.max.get(y)
            ymin = args.min.get(y)
            yunit = args.unit.get(y)
            try:
                yunit = check_unit(y, yunit)
            except LookupError as e:
                return e
            df[y] *= UNIT_FACTORS.get(yunit, 1)

            if axx is not None and y not in ("ev",):
                axx = ax.twinx()
                axx.spines["right"].set_position(("outward", (len(lines) - 1) * 50))
            else:
                axx = ax

            if y == "ev":
                lines.append(
                    ax.vlines(
                        df.loc[df[y].notna(), args.x],
                        0,
                        1,
                        color="lightgrey",
                        label=LABELS.get(y),
                        transform=ax.get_xaxis_transform(),
                    )
                )
            else:
                y_vals = (
                    savgol_filter(df[y], args.smooth, 2) if args.smooth > 0 else df[y]
                )
                lines.extend(
                    axx.plot(
                        df[args.x],
                        y_vals,
                        yfmt,
                        color=ycolor,
                        label=LABELS.get(y, y),
                    )
                )
                axx.set_ylabel(LABELS.get(y, y))
                set_ylim(axx, df[y].min(), df[y].max(), ymin, ymax)
                setup_axis(axx.yaxis, y, yunit)

    if len(lines) > 1:
        ax.legend(handles=lines)
    ax.set_title(args.title)
    plt.show()


if __name__ == "__main__":
    raise SystemExit(main())
